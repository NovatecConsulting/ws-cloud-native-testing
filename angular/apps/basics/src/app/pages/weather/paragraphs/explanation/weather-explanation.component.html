<h2>Principles this pages was tested with:</h2>

<mat-expansion-panel>
  <mat-expansion-panel-header>
    <mat-panel-title> Keep it simple </mat-panel-title>
  </mat-expansion-panel-header>
  <p>
    That means only a little introduction of libraries. Here we use
    <a href="https://tailwindcss.com" target="_blank">tailwindcss</a>, <a href="https://material.angular.io" target="_blank">Angular Material</a> and
    <a href="https://rxjs.dev" target="_blank">RxJS</a>. We could use more but that would lead to growing complexity.
  </p>
</mat-expansion-panel>
<mat-expansion-panel>
  <mat-expansion-panel-header>
    <mat-panel-title> Granular testing </mat-panel-title>
  </mat-expansion-panel-header>
  <p>
    In this application we wanted to show multiple basic concepts of testing. Thus a lot of things are tested in separation, where it is not what the
    user expects. For example, we could add a wrapping component about the location and the result component and test them in conjunction as they are
    most likely never used in separation.
  </p>
  <p>
    If we chose to do so, we should make sure to test only those things in the combined test, that need both elements and test the edge cases of each
    (i.e. input validation) in their own tests to reduce complexity.
  </p>
</mat-expansion-panel>
<mat-expansion-panel>
  <mat-expansion-panel-header>
    <mat-panel-title> Enable Refactorings </mat-panel-title>
  </mat-expansion-panel-header>
  <p>
    We use a lot of granular tests to verify layouts, test for edge cases and alike. But to keep our freedom in refactoring, we established some tests
    that behave like a user would and check for the things a user would look out for. Those give us the freedom to refactor our app as we go. Those
    tests are written in two versions.
  </p>
  <ul>
    <li>
      On an application level (E2E):<br />
      They provide the most abstraction for our refactorings. Depending on the case, we need to replace the selectors, but other than that, they
      should give use certainty, that nothing broke.<br />
      However, those tests take a lot of time to write and maintain. Further, they are prone to false negatives due to renamed identifiers as we often
      forget them while refactoring. And depending on the construction of our application, it might be really hard to set up the test data (i.e.
      complex database requirements). Even this small app gets complicated, when it comes to setting up the database.
    </li>
    <li>
      On a page level:<br />
      Those tests provide great certainty under specific circumstances. In the tests we wrote for the weather page, we rely on the use of certain
      angular material components. I.e. the input for the location is located within a card. We can fix those things by abstracting them away, but
      they will remain at some level.<br />
      However, those tests are written comparably fast and are rather easy to maintain. And they are way easier to set up in regards to data, as we
      can use the angular mocking mechanisms for HTTP communication.
    </li>
  </ul>
  <p>
    If you need those tests and if so which version is totally up to the specific project. As an example, we could have written lower level tests for
    the the weather page as the complexity is rather low and we do not lose track of what changed as fast. Thus checking that everything is bound as
    we want it to would most likely be sufficient.
  </p>
</mat-expansion-panel>
